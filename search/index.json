[{"content":"概述 Quarkus首页放出的标语：超音速亚原子的Java（Supersonic Subatomic Java），它是为OpenJDK HotSpot和GraalVM量身定制的Kubernetes Native Java框架，基于同类最佳的 Java 库和标准制作而成。 Quarkus的到来为开发Linux容器和 kubernetes 原生Java微服务带来了一个创新平台。 Spring Boot是一个基于Java的框架，专注于企业应用，它可以简单使用所有Spring项目，并集成了许多开箱即用的功能，来帮助开发人员提高生产力。 Spring Boot由于其约定优于配置方法，它根据依赖项自动注册默认配置，大大缩短了Java应用程序的开发周期。 Java生态中新兴的技术体系 Spring Reactive(Spring WebFlux) → 背靠 Pivotal → 归属 VMware → 归属戴尔 Quarkus 和 Vert.x → 背靠 Eclipse 基金会 → 主要由 Red Hat 支持 Helidon → 背靠 Oracle Micronaut → 背靠 Object Computing（Grails、OpenDDS） Lagom → 背靠 Lightbend（Akka） 本文重点关注比较热门的Spring Reactive和Quarkus在原生镜像方面的差异。 对比分析 创新和生态系统： Spring 有着长期的历史和丰富的生态系统，许多开发者对其已经非常熟悉。Spring Native 是 Spring 团队为了更好地适应云原生环境（如 Kubernetes）而推出的新项目。相比之下，Quarkus 较新，但它在设计上就考虑了现代云原生和微服务架构，因此在某些方面可能更具创新性。 性能和资源利用： Quarkus 和 Spring Native 都声称可以提供更快的启动时间和减少的内存占用。然而，实际表现可能会因应用程序的具体情况以及你如何使用这些框架而变化。 开发体验： Quarkus 提供的开发模式（live coding）允许开发者在不重启应用的情况下实时看到代码改变的效果，这可能会提高开发效率。Spring Native 则继承了 Spring Boot 的开发体验，使得许多开发者能够很快上手。 兼容性： Spring Native 对于 Spring 生态中的部分库可能还存在兼容性问题，需要按照官方给出的指引进行调整。而 Quarkus 在设计时就尽可能考虑了广泛的兼容性，包括对于 Hibernate，Apache Camel，Eclipse MicroProfile 等开源库的支持。 启动\u0026amp;构建指标对比 指标项 Spring Boot Native Quarkus Native Spring Boot JVM Quarkus JVM 启动耗时（秒） 0.244 0.104 6.156 2.230 启动内存（MB） 44.31 9.05 237.1 119.1 启动CPU使用率（%） - - 0.22 0.26 构建镜像大小（MB） 119.89 84.75 217.92 421.24 构建时长（秒） 592 444 90 17.938 性能测试 资源版本 Mysql: 8.0.32-1.el8 Quarkus: 3.2.2.Final Spring Boot: 3.1.2 JDK: 17.0.8 Docker Engine: 24.0.5 Docker Resource: 4C/8G 压测源码\u0026amp;镜像 压测源码：https://github.com/guanyang/spring-project-samples native-sample: 基于spring native构建原生镜像示例 quarkus-sample: 基于quarkus构建原生镜像示例 镜像资源 Quarkus Native Image: guanyangsunlight/spring-project-samples:quarkus-sample-0.0.1-SNAPSHOT Quarkus JVM Image: guanyangsunlight/spring-project-samples:quarkus-sample-0.0.1-SNAPSHOT-jvm Spring Boot Native Image: guanyangsunlight/spring-project-samples:native-sample-0.0.1-SNAPSHOT Spring Boot JVM Image: guanyangsunlight/spring-project-samples:native-sample-0.0.1-SNAPSHOT-jvm MySQL Image: guanyangsunlight/spring-project-samples:sample-mysql-8.0.32 Docker Compose文件 quarkus-sample native-sample 压测架构 1 2 3 graph LR A(K6施压机) --\u0026gt; B(应用容器) B --\u0026gt;C(MySQL容器) 应用容器：Spring Boot Native,Quarkus Native,Spring Boot JVM,Quarkus JVM每个一个实例 MySQL容器：Mysql8.0容器实例一个 K6施压机: 2.2 GHz 四核Intel Core i7,16 GB 1600 MHz DDR3 K6参考链接：https://k6.io/docs/ 压测场景case Spring Boot Native: 性能指标（QPS、RT）,机器指标（CPU、内存） Quarkus Native: 性能指标（QPS、RT）,机器指标（CPU、内存） Spring Boot JVM: 性能指标（QPS、RT）,机器指标（CPU、内存） Quarkus JVM: 性能指标（QPS、RT）,机器指标（CPU、内存） 压测服务接口 接口地址：${host}/api/test/get/{id} 接口说明：根据id查询数据库记录，host为服务地址，id为数据库记录主键 响应示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;code\u0026#34;: 200, \u0026#34;message\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 4, \u0026#34;version\u0026#34;: 1, \u0026#34;deleted\u0026#34;: 0, \u0026#34;createBy\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;updateBy\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;createTime\u0026#34;: 1695312514000, \u0026#34;updateTime\u0026#34;: 1695312532000, \u0026#34;username\u0026#34;: \u0026#34;test41\u0026#34; } } 压测脚本 总请求时长300s，并发从50开始，并按照50步长增长，命令如下： 1 2 3 4 5 6 k6 run -u 50 --duration 300s -e url=http://127.0.0.1:8082/api/test/get/4 simple-test.js -i：指定请求数量 -u：模拟并发数量 --duration：请求时长定义，例如：60s，1m -e url：指定环境变量url，用于实际场景替换 脚本输出样例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 scenarios: (100.00%) 1 scenario, 50 max VUs, 36s max duration (incl. graceful stop): * default: 50 looping VUs for 6s (gracefulStop: 30s) ✓ is status 200 checks.........................: 100.00% ✓ 7761 ✗ 0 data_received..................: 1.9 MB 324 kB/s data_sent......................: 730 kB 121 kB/s http_req_blocked...............: avg=12.22µs min=1µs med=3µs max=3.26ms p(90)=5µs p(95)=6µs http_req_connecting............: avg=7.1µs min=0s med=0s max=2.19ms p(90)=0s p(95)=0s http_req_duration..............: avg=38.56ms min=7.55ms med=34.26ms max=216.77ms p(90)=58.96ms p(95)=68.51ms { expected_response:true }...: avg=38.56ms min=7.55ms med=34.26ms max=216.77ms p(90)=58.96ms p(95)=68.51ms http_req_failed................: 0.00% ✓ 0 ✗ 7761 http_req_receiving.............: avg=52.57µs min=19µs med=46µs max=680µs p(90)=81µs p(95)=97µs http_req_sending...............: avg=19.87µs min=7µs med=16µs max=1.27ms p(90)=27µs p(95)=38µs http_req_tls_handshaking.......: avg=0s min=0s med=0s max=0s p(90)=0s p(95)=0s http_req_waiting...............: avg=38.49ms min=7.51ms med=34.18ms max=216.58ms p(90)=58.89ms p(95)=68.46ms http_reqs......................: 7761 1288.780058/s iteration_duration.............: avg=38.7ms min=7.76ms med=34.4ms max=218.51ms p(90)=59.08ms p(95)=68.64ms iterations.....................: 7761 1288.780058/s vus............................: 50 min=50 max=50 vus_max........................: 50 min=50 max=50 simple-test.js脚本说明 1 2 3 4 5 6 7 8 9 import http from \u0026#39;k6/http\u0026#39;; import { check } from \u0026#39;k6\u0026#39;; export default function () { const res = http.get(`${__ENV.url}`); check(res, { \u0026#39;is status 200\u0026#39;: (r) =\u0026gt; r.status === 200 }); } 压测指标 被压机器指标 CPU usage Memory usage 被压机器性能指标 QPS Avg Latency(ms) P95(ms) 压测结果 Case QPS Avg Latency P95 CPU usage Memory usage Quarkus Native,-u 50 1699.067212/s 29.41ms 50.07ms 136.91% 23.15MB Quarkus Native,-u 100 1749.35664/s 57.14ms 89.9ms 148.9% 23.95MB Quarkus Native,-u 200 1765.832527/s 113.23ms 167.43ms 156.17% 25.5MB Spring Boot Native,-u 50 1114.946899/s 44.82ms 85.11ms 226.5% 86.23MB Spring Boot Native,-u 100 1175.220721/s 85.06ms 137.26ms 236.07% 96.16MB Spring Boot Native,-u 200 1094.461679/s 182.67ms 284.98ms 246.32% 143.3MB Quarkus JVM,-u 50 2149.507697/s 23.24ms 39ms 111.99% 173.6MB Quarkus JVM,-u 100 2186.80721/s 45.7m 69.6ms 126.62% 174.2MB Quarkus JVM,-u 200 2211.63056/s 90.38ms 130.41ms 125.45% 180.1MB Spring Boot JVM,-u 50 1472.76853/s 33.93ms 65.69ms 199.08% 426.8MB Spring Boot JVM,-u 100 1624.997761/s 61.51ms 97.37ms 211.01% 427.2MB Spring Boot JVM,-u 200 1611.01646/s 124.05ms 188.24ms 214.96% 428.1MB 压测总结 Quarkus Native相较于Spring Boot Native资源消耗更低，性能更好。 Quarkus JVM相较于Spring Boot JVM模式资源消耗更低，性能更好。 Native原生相较于JVM模式整体资源消耗更低，启动更快，构建镜像更小。 优缺点及选型总结 Quarkus优缺点 优点 高度优化的运行时性能和内存管理； 对于开发者友好的开发模式，如实时编程（live coding）； 广泛的兼容性，支持许多主流的 Java 开源库； 面向云原生应用的设计。 缺点 相对于 Spring，其社区规模还较小，可能在某些问题上找不到即时的帮助； 尽管有广泛的兼容性，但并不包括所有的 Java 库。 Spring Boot Native优缺点 优点 建立在 Spring 生态系统之上，易于为已经使用 Spring 的团队接受； 与 Spring Boot 无缝集成，并且借助 GraalVM 提供媲美本机语言的启动速度和内存占用。 支持 AOT（Ahead-of-Time Compilation）编译，可以提高启动速度。 缺点 使用 Spring Boot Native 需要适应其构建过程中将应用程序转化为本地应用程序的复杂性； 构建完成的应用程序虽然启动速度快、内存消耗低，但CPU使用率高于普通 JVM 程序。 技术选型思考 项目需求：如果项目需要快速启动，低内存消耗，那么两者都可以满足。如果已经在使用 Spring Stack，并且想要继续保持使用它，那么 Spring Boot Native 会更加合适。如果项目对开发效率有高要求，那么 Quarkus 可能更符合需求。\n团队技能：如果团队成员已经非常熟悉 Spring Stack，那么采用 Spring Boot Native 可能可以减少学习曲线。反之，如果团队愿意尝试新的技术，并且对响应式编程和函数式编程有兴趣，那么选择 Quarkus 可以是一个不错的选择。\n社区支持和文档：Spring 社区非常活跃，有大量的教程和指南。虽然 Quarkus 比较新，但也在积极扩大其社区，并提供了详细的文档。\n在实际决策过程中，最好能够根据具体情况进行技术选型，可能的话，可以在小规模的项目或者原型中尝试并评估这些框架。\nQuarkus对Spring开发者的额外好处 功能即服务 (FaaS)：当编译为原生二进制文件时，Quarkus 应用程序可以在 0.0015 秒内启动，从而可以将现有的 Spring 和 Java API 知识与 FaaS 功能结合使用。（Azure,AWS Lambda） 实时编码：从“Hello World”示例应用程序开始，然后将其转换为复杂的微服务，而无需重新启动应用程序。只需保存并重新加载浏览器即可查看沿途的变化。 Quarkus 实时编码“开箱即用”，与 IDE 无关。 支持反应式和命令式模型：Quarkus有一个反应式核心，支持传统的命令式模型、反应式模型，或在同一应用程序中同时支持两者。 早期检测依赖注入错误：Quarkus 在编译期间而不是在运行时捕获依赖项注入错误。 最佳框架和标准的结合：Quarkus 在同一应用程序中支持 Spring API 兼容性、Eclipse Vert.x、MicroProfile（JAX-RS、CDI 等）、反应式流和消息传递等。参考《Autowire MicroProfile into Spring Boot》，可以在一个项目中同时使用 Spring 和 MicroProfile API。 参考文档 【Baeldung】Spring Boot vs Quarkus 【LogicMonitor】Quarkus vs Spring Boot Quarkus for Spring Developers Quarkus官方文档 Quarkus入门指南 Quarkus官方代码生成 Create an OCI image GraalVM Native Image Support [Building a Reactive RESTful Web Service](https://spr ","date":"2023-11-05T16:11:08+08:00","image":"https://blog.xcloudapi.com/image/header/cover-3.jpg","permalink":"https://blog.xcloudapi.com/p/spring-native%E4%B8%8Equarkus%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/","title":"Spring Native与Quarkus对比分析"},{"content":"概述 项目管理就是将各种知识、技能、工具与技术应用于项目活动，以满足项目的要求。——《项目管理知识体系指南》 由于项目管理的知识体系过于庞大，PMI 把它分为项目管理五大过程组和十大知识领域，共 49 个子过程。 项目管理十大领域划分 项目管理的十大领域，将项目管理的工作内容划分为：整合管理、范围管理、时间管理、成本管理、质量管理、人力资源管理、沟通管理、干系人管理、风险管理和采购管理。 其中，进度、成本、质量、范围是 4 个核心领域，风险、沟通、采购、资源、干系人管理是 5 个辅助领域和 1 个整体领域。 项目管理五大过程组 项目管理五大过程组，是项目管理的核心内容，是项目管理的四个核心领域的集合。\nPMI 遵循PDCA的法则，将所有的项目管理活动分成了五大过程组，分别是启动过程组、规划过程组、执行过程组、监控过程组和收尾过程组。如下图所示： 启动过程组（千里之行，始于足下）\n启动过程组意味着正式开始一个项目，或者是开始一个项目中的新阶段，包括识别干系人和制定项目章程两个子过程。 规划过程组（运筹帷幄，决胜千里）\n你需要根据预期目标，明确项目范围，确定项目的里程碑阶段目标，为项目的执行做好各项准备。 执行过程组（言出必行，行之必果）\n这个阶段重在整合资源，推进项目落地，完成项目管理计划中确定的工作以实现项目目标。 监控过程组（审时度势，沉着应变）\n你需要定期对项目的进展、范围、质量等进行跟踪和监控，识别目前的进度与计划之间的偏差，从而快速准确地采取办法进行纠正和调整。 收尾过程组（慎终如始，则无败事）\n在这个阶段，你要交付项目成果，组织团队的回顾复盘，归档所有文档等组织过程资产，正式结束一个项目或阶段。 项目管理五大过程组的工作内容 ","date":"2023-11-28T09:30:02+08:00","image":"https://blog.xcloudapi.com/image/header/bg-3.jpg","permalink":"https://blog.xcloudapi.com/p/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%B8%E8%AF%86/","title":"程序员必须要了解的项目管理常识"},{"content":"背景 项目是为创造独特的产品、服务或成果而进行的临时性工作。 项目的特点是：独特的产品、服务或成果，临时性工作，项目驱动变更，创造价值。 项目管理就是将知识、技能、工具与技术应用于项目活动，以满足项目的要求。 程序员做项目管理的误区 误区 1：凡事恨不得事必躬亲 遇到事情时，你不要自己直接去做，而是要想办法驱动他人去做好事情。 你需要讲清楚为什么要做，为什么要现在做，获取理解及认同，激发团队的动力，同时为每个任务选择能力匹配的授权对象。 成功施加影响的三个层次：让人知道要做（Awareness）、有动力做（Desire）和有能力做（Ability）。 误区2：追着别人做监工 做项目管理，不是要你变成监工，而是要你带领团队明确目标，建立机制，并让这个机制运转起来，要始终依靠流程和规则来约束大家的行为。 如果项目团队成员多了，你每天追着成员不停询问进度，那么终将精疲力尽而错失项目全局把控，同时也会招来项目成员因为项目紧张而被你反复追问的不满情绪。 重要的是要建立项目的沟通及反馈机制，保障项目的高效运转及风险提前预警。 误区 3：拿着锤子，看哪里都是钉子 每个项目的现有执行方式，都有它本身的背景和成因，你要与项目中的重要干系人加强沟通，理解前因后果，从项目和团队当前的真实痛点出发，找到真正解决问题的方法和步骤。 可能有些程序员本身是技术骨干出身，对业务或者专业技能比较精通，老是觉得别人做的不够好，需要敲打一下，很多有技术洁癖的人都有这样的想法。想法固然很好，但是你没有三头六臂，抵不过团队的力量。 需要转变观念，相信团队协作的力量远大于个人的累死累活，帮助攻克项目难点，提前预知项目风险，协调运转团队资源才是重中之重。 总结 项目管理最重要的是思想的转变，一个人的力量毕竟有限，充分发挥出团队的执行力才是重中之重。 项目管理的重点不是管控，而是让人理解为什么要做这个项目，做这个项目的目标动力以及选择能力匹配的授权对象来落地执行。 ","date":"2023-11-28T09:25:54+08:00","image":"https://blog.xcloudapi.com/image/header/bg-2.jpg","permalink":"https://blog.xcloudapi.com/p/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%81%9A%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%87%A0%E5%A4%A7%E8%AF%AF%E5%8C%BA/","title":"程序员做项目管理的几大误区"},{"content":"概述 JDK21已于2023年9月19日发布，作为Oracle标准Java实现的一个LTS版本发布，发布了15想新特性，其中虚拟线程呼声较高。 虚拟线程是JDK 21中引入的一项重要特性，它是一种轻量级的线程实现，旨在提高Java应用程序的并发性能。 工作原理 虚拟线程（Virtual Threads）也被称为纤程（Fibers），其基本的工作原理是将线程的调度从操作系统级别转移到用户级别，即由JVM控制。 在传统的线程模型中，每个线程都对应一个操作系统级别的线程，这种线程的创建、切换和销毁等操作都需要系统调用，消耗较大。而且，每个线程都需要一个完整的线程栈，这限制了同时运行的线程数量。 相比之下，虚拟线程并不直接对应一个操作系统级别的线程，而是由JVM管理和调度。多个虚拟线程可能共享一个操作系统级别的线程。这样，当一个虚拟线程阻塞时，JVM可以立即切换到另一个虚拟线程，而无需等待操作系统的调度。而且，虚拟线程不需要一个完整的线程栈，所以可以创建大量的虚拟线程。 JDK 的虚拟线程调度器是一个以FIFO模式运行的ForkJoinPool，调度器可以通过设置启动参数调整，代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 private static ForkJoinPool createDefaultScheduler() { ForkJoinWorkerThreadFactory factory = pool -\u0026gt; { PrivilegedAction\u0026lt;ForkJoinWorkerThread\u0026gt; pa = () -\u0026gt; new CarrierThread(pool); return AccessController.doPrivileged(pa); }; PrivilegedAction\u0026lt;ForkJoinPool\u0026gt; pa = () -\u0026gt; { int parallelism, maxPoolSize, minRunnable; String parallelismValue = System.getProperty(\u0026#34;jdk.virtualThreadScheduler.parallelism\u0026#34;); String maxPoolSizeValue = System.getProperty(\u0026#34;jdk.virtualThreadScheduler.maxPoolSize\u0026#34;); String minRunnableValue = System.getProperty(\u0026#34;jdk.virtualThreadScheduler.minRunnable\u0026#34;); ... //省略赋值操作 Thread.UncaughtExceptionHandler handler = (t, e) -\u0026gt; { }; boolean asyncMode = true; // FIFO return new ForkJoinPool(parallelism, factory, handler, asyncMode, 0, maxPoolSize, minRunnable, pool -\u0026gt; true, 30, SECONDS); }; return AccessController.doPrivileged(pa); } 调度器分配给虚拟线程的平台线程称为虚拟线程的载体线程（carrier）。虚拟线程可以在其生命周期内会被安排在不同的载体线程上。 传统线程池与OS Thread的关系： 虚拟线程VirtualThread与Platform Thread, OS Thread的关系： 虚拟线程在执行到IO操作或Blocking操作时，会自动切换到其他虚拟线程执行，从而避免当前线程等待，可以高效通过少数线程去调度大量虚拟线程，最大化提升线程的执行效率。 如何创建虚拟线程 通过Thread.startVirtualThread()创建 1 2 //创建一个新的并且已启动的虚拟线程 Thread thread = Thread.startVirtualThread(runnable); 通过Thread.ofVirtual()创建 1 2 // 创建一个新的并且已启动的虚拟线程 Thread thread = Thread.ofVirtual().start(runnable); 通过ThreadFactory创建 1 2 3 4 5 6 // 获取线程工厂类 ThreadFactory factory = Thread.ofVirtual().factory(); // 创建虚拟线程 Thread thread = factory.newThread(runnable); // 启动线程 thread.start(); 通过Executors.newVirtualThreadPerTaskExecutor()创建 1 2 3 4 //创建executor ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor(); //通过executor提交任务，采用虚拟线程执行 executor.submit(runnable); 虚拟线程的状态和转换 状态 转换说明 NEW -\u0026gt; STARTED Thread.start STARTED -\u0026gt; TERMINATED failed to start STARTED -\u0026gt; RUNNING first run RUNNING -\u0026gt; PARKING Thread attempts to park PARKING -\u0026gt; PARKED cont.yield successful, thread is parked PARKING -\u0026gt; PINNED cont.yield failed, thread is pinned PARKED -\u0026gt; RUNNABLE unpark or interrupted PINNED -\u0026gt; RUNNABLE unpark or interrupted RUNNABLE -\u0026gt; RUNNING continue execution RUNNING -\u0026gt; YIELDING Thread.yield YIELDING -\u0026gt; RUNNABLE yield successful YIELDING -\u0026gt; RUNNING yield failed RUNNING -\u0026gt; TERMINATED done 虚拟线程最佳实践 以下说明都是基于JDK21环境示例，如果是JDK19，则需要开启预览配置--enable-preview\n示例源码参考：virtualthread-sample 在SpringBoot中使用虚拟线程处理请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @EnableAsync @Configuration @ConditionalOnProperty(value = \u0026#34;spring.executor\u0026#34;, havingValue = \u0026#34;virtual\u0026#34;) public class ThreadConfig { //为每个异步任务提供虚拟线程执行Executor @Bean public AsyncTaskExecutor applicationTaskExecutor() { return new TaskExecutorAdapter(Executors.newVirtualThreadPerTaskExecutor()); } //为tomcat提供虚拟线程执行Executor @Bean public TomcatProtocolHandlerCustomizer\u0026lt;?\u0026gt; protocolHandlerVirtualThreadExecutorCustomizer() { return protocolHandler -\u0026gt; { protocolHandler.setExecutor(Executors.newVirtualThreadPerTaskExecutor()); }; } } 在application.yml中添加配置来启用虚拟线程 1 2 3 spring: #配置virtual表示启用虚拟线程，非virtual表示不启用，可以通过环境变量SPRING_EXECUTOR指定 executor: ${SPRING_EXECUTOR:virtual} 添加测试入口进行虚拟线程测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RestController @SpringBootApplication public class VirtualthreadSampleApplication { public static void main(String[] args) { SpringApplication.run(VirtualthreadSampleApplication.class, args); } @GetMapping(\u0026#34;/hello/{timeMillis}\u0026#34;) public Object hello2(@PathVariable long timeMillis) throws InterruptedException { Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;time\u0026#34;, System.currentTimeMillis()); map.put(\u0026#34;msg\u0026#34;, \u0026#34;Hello World!\u0026#34;); //查看当时线程信息，识别是否是虚拟线程 map.put(\u0026#34;thread\u0026#34;, Thread.currentThread().toString()); //模拟耗时IO操作 Thread.sleep(timeMillis); return map; } } 性能测试 资源版本 Spring Boot: 3.1.4 JDK: graalvm-jdk-21 Docker Engine: 24.0.5 Docker Resource: 4C/8G 压测源码\u0026amp;镜像 压测源码：https://github.com/guanyang/spring-project-samples/tree/main/virtualthread-sample 镜像资源 Dockerfile: virtualthread-sample/src/main/docker/Dockerfile 已构建示例镜像: guanyangsunlight/spring-project-samples:virtualthread-sample-0.0.1-SNAPSHOT JMH测试代码: virtualthread-sample/src/test/java/org/gy/demo/virtualthread/ThreadTest.java http测试接口：${host}/hello/{timeMillis}, host为服务地址，timeMillis为模拟IO操作的时间，单位毫秒，响应示例如下： 1 2 3 4 5 { msg: \u0026#34;Hello World!\u0026#34;, time: 1695871679753, thread: \u0026#34;VirtualThread[#59]/runnable@ForkJoinPool-1-worker-1\u0026#34; } 压测工具 K6: 压测http请求，参考链接：https://k6.io/docs/ JMH: 由OpenJDK团队开发的一款基准测试工具，参考链接：https://github.com/openjdk/jmh 压测场景case 【基于K6】Spring Boot虚拟线程: 性能指标（QPS、Avg Latency、P95） 【基于K6】Spring Boot普通线程: 性能指标（QPS、Avg Latency、P95） 【基于JMH】普通线程任务调度执行: 平均响应时间（AverageTime） 【基于JMH】虚拟线程任务调度执行: 平均响应时间（AverageTime） K6压测 压测脚本 总请求时长60s，并发从200开始，并按照200步长增长，命令如下： 1 2 3 4 5 6 k6 run -u 200 --duration 60s -e url=http://127.0.0.1:8081/hello/100 simple-test.js -i：指定请求数量 -u：模拟并发数量 --duration：请求时长定义，例如：60s，1m -e url：指定环境变量url，用于实际场景替换 simple-test.js脚本说明 1 2 3 4 5 6 7 8 9 import http from \u0026#39;k6/http\u0026#39;; import { check } from \u0026#39;k6\u0026#39;; export default function () { const res = http.get(`${__ENV.url}`); check(res, { \u0026#39;is status 200\u0026#39;: (r) =\u0026gt; r.status === 200 }); } 压测docker实例 1 2 3 4 5 ## 启用虚拟线程实例 docker run --name virtualthread-sample-vt -p 8081:8080 -e SPRING_EXECUTOR=virtual -d guanyangsunlight/spring-project-samples:virtualthread-sample-0.0.1-SNAPSHOT ## 启用普通线程实例 docker run --name virtualthread-sample -p 8082:8080 -e SPRING_EXECUTOR=none -d guanyangsunlight/spring-project-samples:virtualthread-sample-0.0.1-SNAPSHOT K6压测结果 Case QPS Avg Latency P95 Spring Boot虚拟线程,-u 200 1620.869685/s 123.09ms 149.42ms Spring Boot虚拟线程,-u 400 2202.121674/s 180.84ms 277.14ms Spring Boot虚拟线程,-u 600 3195.845398/s 186.44ms 256.03ms Spring Boot虚拟线程,-u 800 3780.654388/s 210.28ms 294.79ms Spring Boot虚拟线程,-u 1000 4250.384928/s 234.17ms 319.92ms Spring Boot虚拟线程,-u 1200 4479.450088/s 266.15ms 370.17ms Spring Boot普通线程,-u 200 1418.709029/s 140.69ms 218.24ms Spring Boot普通线程,-u 400 1888.860872/s 210.91ms 247.39ms Spring Boot普通线程,-u 600 1889.607486/s 315.49ms 373.9ms Spring Boot普通线程,-u 800 1954.985051/s 405.99ms 428.44ms Spring Boot普通线程,-u 1000 1917.568269/s 516.33ms 585.76ms K6压测总结 以上实例都是在jvm默认参数及tomcat线程池默认200大小场景下进行，没有进行任何调优配置\n采用虚拟线程模式，随着并发数的提高，性能提升比较明显，整体性能明显优于普通线程模式。 采用普通线程模式，由于tomcat默认线程池配置，增加并发数并不能明显提升QPS，由于阻塞等待导致耗时边长。 虚拟线程在执行到IO操作或Blocking操作时，会自动切换到其他虚拟线程执行，从而避免当前线程等待，可以高效通过少数线程去调度大量虚拟线程，最大化提升线程的执行效率。 基于JMH任务调度测试 基础配置说明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @BenchmarkMode({Mode.AverageTime}) //平均响应时间模式 @OutputTimeUnit(TimeUnit.MILLISECONDS) //输出单位：毫秒模式 @State(Scope.Benchmark) //作用域为本次JMH测试，线程共享 @Fork(value = 1) //fork出一个JVM进程 @Threads(4) //使用4个线程去执行测试方法 @Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS) //预热迭代5次，每次一秒 @Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS) //测试迭代5次，每次一秒 public class ThreadTest { @Param({\u0026#34;500\u0026#34;, \u0026#34;1000\u0026#34;, \u0026#34;2000\u0026#34;}) //模拟任务调度次数，分别500次，1000次，2000次 private int loop; @Param({\u0026#34;50\u0026#34;, \u0026#34;100\u0026#34;, \u0026#34;200\u0026#34;}) //模拟线程池大小，也是虚拟线程调度器大小 private int nThreads; private ExecutorService executor; private ExecutorService virtualExecutor; @Setup //每个测试方法前初始化 public void setup() { //普通线程方式 executor = Executors.newFixedThreadPool(nThreads); //定义虚拟线程调度器大小，保持跟平台线程池大小一样 System.setProperty(\u0026#34;jdk.virtualThreadScheduler.maxPoolSize\u0026#34;, String.valueOf(nThreads)); virtualExecutor = Executors.newVirtualThreadPerTaskExecutor(); } @TearDown //每个测试方法执行后销毁 public void tearDown() { executor.close(); virtualExecutor.close(); } //主函数启动测试 public static void main(String[] args) throws RunnerException { Options opt = new OptionsBuilder().include(ThreadTest.class.getSimpleName()).build(); new Runner(opt).run(); } //普通线程测试用例 @Benchmark public void platformThreadTest(Blackhole bh) { //模拟多个任务调度测试，返回最终结果 List\u0026lt;Integer\u0026gt; result = execute(loop, executor, ThreadTest::sleepTime); bh.consume(result); } //虚拟线程测试用例 @Benchmark public void virtualThreadTest(Blackhole bh) { //模拟多个任务调度测试，返回最终结果 List\u0026lt;Integer\u0026gt; result = execute(loop, virtualExecutor, ThreadTest::sleepTime); bh.consume(result); } //模拟多个任务调度测试，返回最终结果 private static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; execute(int loop, ExecutorService executor, Supplier\u0026lt;T\u0026gt; supplier) { CompletableFuture\u0026lt;T\u0026gt;[] futures = new CompletableFuture[loop]; for (int i = 0; i \u0026lt; loop; i++) { //模拟执行耗时任务 futures[i] = CompletableFuture.supplyAsync(supplier, executor); } CompletableFuture\u0026lt;Void\u0026gt; result = CompletableFuture.allOf(futures); result.join(); return Stream.of(futures).map(f -\u0026gt; f.getNow(null)).filter(Objects::nonNull).collect(Collectors.toList()); } //sleep方法，模拟耗时IO操作，目前暂定30ms @SneakyThrows private static int sleepTime() { Thread.sleep(Duration.ofMillis(sleepTimeMillis)); return sleepTimeMillis; } ... } JMH测试结果 Score表示平均响应时间(ms)，越小越好，loop表示任务次数，nThreads表示线程数，也是虚拟线程调度器大小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Benchmark (loop) (nThreads) Mode Cnt Score Error Units ThreadTest.platformThreadTest 500 50 avgt 5 1090.077 ± 324.304 ms/op ThreadTest.platformThreadTest 500 100 avgt 5 568.331 ± 106.303 ms/op ThreadTest.platformThreadTest 500 200 avgt 5 294.539 ± 17.419 ms/op ThreadTest.platformThreadTest 1000 50 avgt 5 2118.651 ± 426.003 ms/op ThreadTest.platformThreadTest 1000 100 avgt 5 923.840 ± 226.815 ms/op ThreadTest.platformThreadTest 1000 200 avgt 5 534.198 ± 115.960 ms/op ThreadTest.platformThreadTest 2000 50 avgt 5 4013.412 ± 2046.025 ms/op ThreadTest.platformThreadTest 2000 100 avgt 5 1828.609 ± 413.867 ms/op ThreadTest.platformThreadTest 2000 200 avgt 5 938.532 ± 173.568 ms/op ThreadTest.virtualThreadTest 500 50 avgt 5 31.733 ± 0.380 ms/op ThreadTest.virtualThreadTest 500 100 avgt 5 31.747 ± 0.468 ms/op ThreadTest.virtualThreadTest 500 200 avgt 5 31.771 ± 0.236 ms/op ThreadTest.virtualThreadTest 1000 50 avgt 5 32.783 ± 1.654 ms/op ThreadTest.virtualThreadTest 1000 100 avgt 5 32.827 ± 0.959 ms/op ThreadTest.virtualThreadTest 1000 200 avgt 5 32.672 ± 0.894 ms/op ThreadTest.virtualThreadTest 2000 50 avgt 5 34.578 ± 1.554 ms/op ThreadTest.virtualThreadTest 2000 100 avgt 5 35.001 ± 1.889 ms/op ThreadTest.virtualThreadTest 2000 200 avgt 5 35.236 ± 1.127 ms/op JMH测试总结 虚拟线程在执行到IO操作或Blocking操作时性能提升十分明显，有数量级的提升，非常适合IO密集型的场景。 总结 虚拟线程是Java为了解决并发编程中的一些常见问题而引入的新特性，特别是在I/O操作方面。以下是虚拟线程优缺点及使用场景总结：\n优点： 资源使用低：虚拟线程比传统线程消耗更少的资源。 简化并发编程：虚拟线程允许直接为每一个任务创建一个线程，而不需要复杂的线程池或者任务调度策略。 提高吞吐量和响应时间：由于虚拟线程可以快速切换，所以它们可以帮助减小延迟并提高系统的吞吐量。 缺点： 仍处于试水阶段：虚拟线程属于新特性，生产环境暂无应用验证，处于试水阶段。 与现有代码的兼容性问题：一些依赖于线程本地存储（Thread Local Storage, TLS）或者同步原语的既有代码可能无法正确地在虚拟线程上运行。 调试和监控工具支持：当前，许多Java的调试和监控工具还不完全支持虚拟线程。 使用场景： 高并发应用：例如Web服务器、消息队列等，可以为每个请求或任务启动一个单独的虚拟线程，以提高系统的吞吐量。 异步编程：虚拟线程可以简化异步编程模型，使得你可以写出看起来像同步代码的异步代码。 微服务架构：在微服务架构中，通常需要处理大量的网络请求，虚拟线程可以帮助提高系统的响应能力。 还需要注意的是，虽然虚拟线程对于某些场景非常有用，但并不是所有问题都适合使用虚拟线程来解决。你应该根据项目的具体需求和环境选择最合适的工具。\n","date":"2023-11-05T16:18:08+08:00","image":"https://blog.xcloudapi.com/image/header/bg-1.jpg","permalink":"https://blog.xcloudapi.com/p/jdk21%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/","title":"JDK21虚拟线程原理及实践"},{"content":"概述 在Spring Webflux中，有两个关键的调度器操作符：publishOn和subscribeOn。理解它们的用途和差异是使用WebFlux进行反应式编程的重要部分。\nsubscribeOn：这个操作符定义了产生数据的线程。无论在哪里放置subscribeOn，都只会影响源头的执行线程。如果在一个流的多个地方使用subscribeOn，只有第一个起作用。 publishOn：这个操作符可以影响其后续操作运行的线程。如果在流中的多个地方使用publishOn，每个都会起作用，并且会改变其后续操作的执行线程。 Scheduler调度器 在Spring WebFlux中，Scheduler（调度器）是Project Reactor中的一个概念，它负责控制并发和线程切换。 主要有以下几种常见类型的Scheduler：\nSchedulers.immediate()：直接在当前线程执行任务，不进行线程切换。 Schedulers.single()：创建一个只包含一个线程的调度器，所有任务都在这个单一线程上执行。如果这个线程出现故障，将创建一个新的线程替代它。 Schedulers.elastic()：创建一个弹性的线程池，适用于IO阻塞操作比如数据库查询、文件读写等。该线程池会根据需要创建新的线程，如果线程闲置时间过长则会被销毁。弹性线程池可以无限大，所以要注意不要在大量计算密集型的任务中使用它，因为这可能导致创建大量线程，消耗过多系统资源。 Schedulers.parallel()：创建一个固定大小的线程池，线程数量默认等于CPU核心数。适用于计算密集型任务，因为这类任务能够充分利用CPU资源。 Schedulers.boundedElastic()：创建一个有界的弹性线程池，适合I/O任务。它与Schedulers.elastic()相似，但有最大线程数和队列大小的限制。 publishOn和subscribeOn使用场景 使用Scheduler的方法主要是通过publishOn和subscribeOn两个操作符。\n使用publishOn将数据流中后续的处理操作在parallel调度器对应的线程池中执行 1 flux.publishOn(Schedulers.parallel()).map(this::blockMethod) 使用subscribeOn将源头的操作在boundedElastic调度器对应的线程池中执行 1 Mono.fromCallable(this::blockMethod).subscribeOn(Schedulers.boundedElastic()) 两者的区别 publishOn常用于切换执行下游操作符的线程，影响范围和它的位置有关。 subscribeOn常用于切换源头数据生成的线程，影响范围则和位置无关。 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import org.junit.jupiter.api.Test; import reactor.core.publisher.Flux; import reactor.core.scheduler.Schedulers; public class PublishOnAndSubscribeOnTests { @Test public void testPublishOnAndSubscribeOn() { Flux.just(\u0026#34;Hello\u0026#34;).map(s -\u0026gt; { System.out.println(\u0026#34;[1] Thread name: \u0026#34; + Thread.currentThread().getName()); return s.concat(\u0026#34; World\u0026#34;); }).publishOn(Schedulers.newParallel(\u0026#34;thread-publishOn\u0026#34;)).map(s -\u0026gt; { System.out.println(\u0026#34;[2] Thread name: \u0026#34; + Thread.currentThread().getName()); return s; }).subscribeOn(Schedulers.newSingle(\u0026#34;thread-subscribeOn\u0026#34;)).subscribe(s -\u0026gt; { System.out.println(\u0026#34;[3] Thread name: \u0026#34; + Thread.currentThread().getName()); System.out.println(s); }); } } 输入结果如下： 1 2 3 4 [1] Thread name: thread-subscribeOn-1 [2] Thread name: thread-publishOn-1 [3] Thread name: thread-publishOn-1 Hello World 从上面的例子可以看出，subscribeOn定义在publishOn之后，但是却从源头开始生效。 而在publishOn执行之后，线程池变更为publishOn所定义的。 总结 在实际使用中，我们可以根据需要选择使用publishOn或subscribeOn，它们可以帮助我们更好地控制程序的并发行为和系统资源的利用。 然而，publishOn与subscribeOn也有一些局限性： 1 2 1.无法解决所有并发问题：虽然它们可以将任务移至其他线程执行，但如果你的程序设计本身就没有考虑到并发安全，那么使用这两者仍可能出现问题。 2.线程切换开销：每次通过publishOn或subscribeOn进行线程切换时，都会产生一定的系统开销。如果大量无谓的线程切换，可能会对性能产生负面影响。 ","date":"2023-11-05T16:38:08+11:00","image":"https://blog.xcloudapi.com/image/header/bg-3.jpg","permalink":"https://blog.xcloudapi.com/p/spring-webflux%E4%BD%BF%E7%94%A8subscribeon%E5%92%8Cpublishon%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","title":"Spring Webflux使用subscribeOn和publishOn的最佳实践"},{"content":"概述 虚拟线程是JDK 21中引入的一项重要特性，它是一种轻量级的线程实现，旨在提高Java应用程序的并发性能。 虚拟线程（Virtual Threads）也被称为纤程（Fibers），其基本的工作原理是将线程的调度从操作系统级别转移到用户级别，即由JVM控制。 Spring WebFlux是Spring Framework的一个模块，它提供了一种基于响应式编程模型的Web开发框架。 Spring WebFlux支持两种编程模型，分别是注解驱动和函数式编程。在注解驱动模型中，可以使用类似于Spring MVC的注解来定义请求处理方法，并利用Reactor提供的操作符和流式处理方式来处理请求和响应。在函数式编程模型中，可以使用一组函数式接口来定义路由和处理函数，以及利用Flux和Mono来处理异步数据流。 虚拟线程和webflux的性能对决 环境及配置 Spring Boot: 3.1.4 JDK: graalvm-jdk-21 Docker Engine: 24.0.5 Docker Resource: 4C/8G 压测源码\u0026amp;镜像 源码仓库：https://github.com/guanyang/spring-project-samples 虚拟线程源码示例：virtualthread-sample webflux源码示例：webflux-sample 已构建示例镜像如下： 1 2 1.虚拟线程镜像: guanyangsunlight/spring-project-samples:virtualthread-sample-0.0.1-SNAPSHOT 2.webflux镜像：guanyangsunlight/spring-project-samples:webflux-sample-0.0.1-SNAPSHOT http测试接口：${host}/hello/{timeMillis}, host为服务地址，timeMillis为模拟IO操作的时间，单位毫秒，响应示例如下： 1 2 3 4 5 { msg: \u0026#34;Hello World!\u0026#34;, time: 1695871679753, thread: \u0026#34;VirtualThread[#59]/runnable@ForkJoinPool-1-worker-1\u0026#34; } 压测工具 K6: 压测http请求，参考链接：https://k6.io/docs/ 压测场景case Spring Boot虚拟线程: 性能指标（QPS、Avg Latency、P95） Spring webflux响应式: 性能指标（QPS、Avg Latency、P95） K6压测 压测脚本 总请求时长60s，并发从200开始，并按照200步长增长，命令如下： 1 2 3 4 5 6 k6 run -u 200 --duration 60s -e url=http://127.0.0.1:8081/hello/100 simple-test.js -i：指定请求数量 -u：模拟并发数量 --duration：请求时长定义，例如：60s，1m -e url：指定环境变量url，用于实际场景替换 simple-test.js脚本说明 1 2 3 4 5 6 7 8 9 import http from \u0026#39;k6/http\u0026#39;; import { check } from \u0026#39;k6\u0026#39;; export default function () { const res = http.get(`${__ENV.url}`); check(res, { \u0026#39;is status 200\u0026#39;: (r) =\u0026gt; r.status === 200 }); } 压测docker实例 1 2 3 4 5 ## 启用虚拟线程实例 docker run --name virtualthread-sample-vt -p 8081:8080 -e SPRING_EXECUTOR=virtual -d guanyangsunlight/spring-project-samples:virtualthread-sample-0.0.1-SNAPSHOT ## 启用webflux实例 docker run --name webflux-sample -p 8083:8080 -d guanyangsunlight/spring-project-samples:webflux-sample-0.0.1-SNAPSHOT K6压测结果 QPS对比 Avg Latency对比 详细数据 Case QPS Avg Latency P95 Spring Boot虚拟线程,-u 200 1620.869685/s 123.09ms 149.42ms Spring Boot虚拟线程,-u 400 2634.599143/s 151.55ms 198.37ms Spring Boot虚拟线程,-u 600 3136.075961/s 186.44ms 256.03ms Spring Boot虚拟线程,-u 800 3780.654388/s 210.28ms 294.79ms Spring Boot虚拟线程,-u 1000 4250.384928/s 234.17ms 319.92ms Spring Boot虚拟线程,-u 1200 4479.450088/s 266.15ms 370.17ms Spring webflux响应式,-u 200 1826.774964/s 109.22ms 127.25ms Spring webflux响应式,-u 400 3516.072783/s 113.35ms 138.09ms Spring webflux响应式,-u 600 4868.593872/s 122.69ms 160.59ms Spring webflux响应式,-u 800 5852.713635/s 136.14ms 182.87ms Spring webflux响应式,-u 1000 5994.725404/s 166.09ms 255.77ms Spring webflux响应式,-u 1200 6878.047424/s 173.48ms 278.69ms 总结 Spring WebFlux和JDK虚拟线程是两种不同的技术，用于解决不同的问题，并具有不同的使用场景。下面是它们之间的对比及使用场景：\n两者对比 异步与同步：Spring WebFlux基于非阻塞I/O和异步处理方式，适用于需要处理大量并发请求和对响应时间要求较高的场景。而JDK虚拟线程可以看作是一种用户级线程，通过协程或轻量级线程实现并发编程，适用于需要处理大量任务和对资源利用率要求较高的场景。 编程模型：Spring WebFlux提供了注解驱动和函数式编程两种编程模型，借助Reactor库来处理异步数据流。而JDK虚拟线程通常可以使用协程库（如Quasar）或并发框架（如CompletableFuture）来实现轻量级线程的功能。 生态系统：Spring WebFlux是Spring Framework的一部分，与其他Spring组件和工具集成紧密，丰富的生态系统给开发人员带来便利。JDK虚拟线程的生态系统相对较小，可能缺乏一些成熟的库和工具支持。 学习曲线：Spring WebFlux相对于传统的Servlet API和阻塞I/O模型有较陡峭的学习曲线，需要开发人员学习响应式编程和相关的Reactor库。JDK虚拟线程相对较容易上手。 使用场景对比 使用Spring WebFlux： 1 2 3 1.需要处理大量并发请求和对响应时间有较高要求的场景。 2.需要利用异步处理提高系统的吞吐量和响应性能。 3.希望借助Spring Framework的丰富生态系统来简化开发。 使用JDK虚拟线程： 1 2 3 1.需要处理大量任务和对资源利用率有较高要求的场景。 2.希望通过协程或轻量级线程实现更灵活、可控的并发编程。 3.需要快速启动和停止线程。 需要根据具体的需求和项目情况来选择适合的技术。在某些场景下，可能也可以将两者结合使用，以充分发挥各自的优势。\n","date":"2023-11-05T16:25:08+18:00","image":"https://blog.xcloudapi.com/image/header/bg-2.jpg","permalink":"https://blog.xcloudapi.com/p/jdk21%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E5%92%8Cwebflux%E6%80%A7%E8%83%BD%E5%AF%B9%E5%86%B3/","title":"JDK21虚拟线程和webflux性能对决"}]